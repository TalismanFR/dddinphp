Глава 3. Объекты-Значения (The Value Objects)
==

Объекты-Значения являются фундаментальным строительным блоком DDD, и они используются для моделирования концепции вашего 
Единого Языка в коде. Объект Значения - это не просто вещь в вашем домене - 
он измеряет, определяем количество или описывает что-то. Объекты Значения могут рассматриваться
как небольшие простые объекты, такие как деньги или диапозон дат, равенство
которых основано не на идентификаторе, а на содержании.

Например, цена продукта может быть смоделирована с использованием Объекта Значения.
В данном случае это не вещь, а ценность, которая позволяет нам измерить, сколько
денег стоит продукт. Объем памяти для таких объектов легко определяется (рассчитывается
по составным частям), а накладных расходов очень мало. В результате создание нового экземпляра
предпочтительнее повторного использования ссылок, даже если Объект-Значения использоуется для
предоставления одного и того же значения. Равенство проверяется на основе сопоставимости
всех полей экземпляров.

## Определение
Уорд Каннингем (Ward Cunningham) дает следующее [определение](http://c2.com/cgi/wiki?ValueObject) Объекту Значения:
>Это мера или описание чего-либо. Примерами Объектов Значения являются такие вещи, как числа, даты, денежные суммы и строки.
>Обычно это не большие Объекты, которые используются довольно широко.
>Их идентичность основана на их состояни, а не на идентификаторе Объекта. 
>Таким образом, вы можете иметь несколько копий одного концептуального Объекта Значения.
>Каждая банкнота достоинством 5 долларов имеет свою собственную идентификацию (благодаря
>своему серийному номеру), но экономия денежных средств зависит от того, что
>каждая банкнота достоинством в 5 долларов имеет ту же стоимость, что и любая другая банкнота в 5 долларов.

Мартин Фаулер дает следующее [определение](http://martinfowler.com/bliki/ValueObject.html) Объекту Значения:
>Это маленький Объект, такой как деньги или диапозон дат. Их ключевое свойство
>заключается в том, что они следуют семантике значений, а не ссылочной семантике.
>Мы можем так утверждать, потому что их понятие равенства не основано на идентификаторе,
>вместо этого два Объекта Значения равны, если все их поля равны. 
>Хотя все поля равны, вам не нужно сравнивать все поля, если подмножество уникально - 
>например, кодов валюты для объектов валюты достаточно чтобы проверить равенство.
>Общая эвристика заключается в том, что Объекты Значения должны быть полностью неизменными.
>Если вы хотите изменить объект значения, вы должны заменить объект новым и не иметь
>возможности обновлять значения самого Объекта Значения. Обновляемые Объекты Значения приводят
>к проблемам с наложением имен.

Примерами Объектов Значения являются числа, текстовые строки, даты, время, полное имя человека
>***Упражнение***
>Попробуйте найти дополнительные Объекты Значения в вашем текущем Домене.

## Объекты значения vs Сущности

Рассмотрим следующие примеры из [Википедии](http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD), чтобы лучше понять разница между
Объектами Значениями и Сущностями:
- Объект Значения. Когда люди обменивают долларовые банкноты, они обычно не 
различают каждый уникальную купюру; они обеспокоены только номинальной стоимостью
долларовой банкноты. В этом контексте далларовые банкноты ялвяются Объектами Значения.
Тем не менее, Федеральный Резерв может быть обеспокоен каждым уникальным счетом; в этом контексте
каждый счет был бы сущностью.
- Сущность. Большинство авиакомпаний различают каждое место уникально на каждом рейсе.
Каждое место в данном контексте является сущностью. Однако Southwest Airlines, EasyJet и
Ryanair не различают каждое место; все места одинаковые. В этом контексте место на самом деле является
Объектом Значения.

>***Упражнение***
>Подумайте о понятии адреса (индекс, улица, номер дома и т.д.). Каков возможный
>контекст, в котором адрес может быть смоделирован как сущность, а не как объект значения? 
>Обсудите ваши выводы с коллегами.

## Пример "Валюта" и "Стоимость"

Объекты Значения "Валюта" и "Денежная Стоимость", вероятно, являются наиболее
часто используемыми примерами для объяснения Объектов Значения, благодаря 
[патерну "Деньги" (Money)](http://martinfowler.com/eaaCatalog/money.html).
Этот шаблон проектирования предоставляет решение для моделирования задачи, которая позволяет
избежать проблемы округления с плавающей запятой, что, в свою очередь, позволяет выполнять
детерминированные вычисления.

В реальном мире валюта описывает денежные единицы так же, как метры и ярды описывают единицы расстояния.
Каждая валюта представлена трехбуквенным ISO кодом в верхнем регистре:
```php
class Currency
{
    private $isoCode;
    public function __construct($anIsoCode)
    {
        $this->setIsoCode($anIsoCode);
    }

    private function setIsoCode($anIsoCode)
    {
        if (!preg_match('/^[A-Z]{3}$/', $anIsoCode)) {
            throw new InvalidArgumentException();
        }
        $this->isoCode = $anIsoCode;
    }

    public function isoCode()
    {
        return $this->isoCode;
    }
}
```
Одна из основных целей Объектов Значения так же являются святым Граалем ООП: инкапсуляция.
Следуя этому шаблону, вы получите выделенное место для размещения всей проверки,
логики сравнения и поведения для данной концепции.

>***Дополнительные Проверки Валюты***
>В предыдущем примере кода мы можем построить валюту с кодом ISO равным ААА.
>Это не валидно, валюты с такой кодировкой не существует. Напишите более конкретное правило,
>которое проверит, действителен ли код ISO. Полный список действительный валютных кодов ISO 
>можно найти 
>[здесь](https://www.xe.com/iso4217.php). Если вам нужна помощь, взгляните на библиотеку 
>[Money Packagist](https://github.com/moneyphp/money)

Деньги используются для измерения определенной суммы валюты. Они моделируются с 
помощью суммы и валюты. Сумма, в случае паттерна Money, реализуется с использованием
целочисленного представления наименее значимой доли валюты - например, в центах долларов США или 
копеек в рублях России.

В качестве бонуса вы также можете заметить, что мы используем самоинкапсуляцию
для установки кода ISO, которая центарлизует изменения в самом Объекте Значения:
```php
class Money
{
    private $amount; 
    private $currency;

    public function __construct($anAmount, Currency $aCurrency)
    {
        $this->setAmount($anAmount);
        $this->setCurrency($aCurrency);
    }

    private function setAmount($anAmount)
    {
        $this->amount = (int) $anAmount;
    }

    private function setCurrency(Currency $aCurrency)
    {
        $this->currency = $aCurrency;
    }

    public function amount()
    {
        return $this->amount;
    }

    public function currency()
    {
        return $this->currency;
    }
}
```
Теперь, когда вы знаете формальное определение Объектов Значений, давайте
углубимся в тот мощной функционал который они предоставляют.

## Характеристики

При моделированние концепции Единого Языка вашего Домена, вы всегда должны отдавать
предпочтение Объектам Значения, а не Сущностям. Объекты Значения проще создавать, тестировать, 
использовать и поддерживать.

Исходя из этого, вы можете определить, может ли рассматриваемая концепция моделироваться как 
Объект Значения, если:

- Он измеряет, оценивает или описывает объект предметной области.
- Он может быть имутабельным (неизменяемым).
- Он моделирует концептуальное целое, объединяя связанные атрибуты в единое целое.
- Он может быть сравнен с другим таким же объектом через равенство всех его аттрибутов.
- Он полностью заменяется при изменении способа измерения или описания.
- Он предоставляет связанным с ним объектам функцию без побочных эффектов.

### Измерение, Оценивание, или Описание
Как говорилось выше, Объект Значения не должен рассматриваться как вещь в вашем Домене.
В качестве значения Объект Значения измеряет, оценивает или описывает концепцию в Домене.

В нашем примере объект `Currency` описывает тип объекта `Money`. Объект `Money` измеряет
или количественно оценивает единицы данной валюты.

### Имутабельность
Это один из важнейших аспектов для усвоения. Объекты Значения не могут быть измнены в 
течении всего периода их использования. Благодаря этой имутабельности Объект Значения
легко создавать и тестировать, они не содержат нежелательных/неожиданных побочных эффектов.
Таким образом, Объекты Значения должны создаваться через их конструкторы. 
Чтобы создать его, вы обычно передаете необходимые типы притивов или другие Объект Значения
через конструктор.

Объекты Знечения всегда находятся в валидном состоянии; Вот почему мы создаем их за один
шаг. Пустые конструкторы с несколькими сеттерами или геттерами переносят 
ответственность за создание на клиента что приводит к Анемичность Доменой Модели, что считается антипатерном.

Также важно отметить, что не рекомендуется хранить ссылки на Сущности внутри ваших Объектов Значения.
Сущности являются изменяемыми, и хранение ссылок на них может привести к 
нежелательным побочным эффектам в Объекте Значения.

В языках с `перегрузкой методов` таких как Java, вы можете создавать несколько
конструкторов с одинаковыми именами. Каждому из этих конструкторов предоставляются
различные входные параметры для создания одного и того же типа результирующего объекта.
В PHP мы можем реализовать аналогичную возможность с помощью фабричных методов.
Эти специфичные фабричные методы также известны как семантические конструкторы.
Основная цель `fromMoney` метода предоставить больше контекстуального значения, чем 
простой конструктор. Более радикальные подходы предлагают сделать метод
`__construct` приватным и для создания объекта используют семантический конструктор.

В нашем объекте `Money` мы могли бы реализовать несколько полезных 
фабричных методово, какие как:
 ```php
class Money
{
    // ...
    public static function fromMoney(Money $aMoney)
    {
        return new self(
            $aMoney->amount(),
            $aMoney->currency()
        );
    }
    public static function ofCurrency(Currency $aCurrency)
    {
        return new self(0, $aCurrency);
    }
}
```
Использую ключевое слово `self`, мы не связываем код с именем класса. 
Таким образом, изменение имени класса или пространства имен не повлияет на работоспособность
фабричных методов. Эта маленькая деталь реализации поможет нам при рефакторинге на более
познем этапе.

>***`static` или `self`***
>Использование `static` вместо `self` может привести к нежелательным проблемам, когда Объект Значения
>наследуется от другого Объекта Значения.

Учитывая имутабельность, нам нужно понять как обрабатывать действия изменения объекта, которые
обычно встречаются в контексте состояния. Если нам требуется измненеия состояния, мы должны вернуть
новой экземпляр Объекта Значения в котором учтено это измненение. Например если мы хотим увеличить
сумму Объекта Значения `Money`, мы вместо того чтобы этому объекту присвоить новое значени должны создать и вернуть новый объект.

К счастью, следовать этому правилу достаточно просто:
```php
class Money
{
    // ...
    public function increaseAmountBy($anAmount)
    {
        return new self(
            $this->amount() + $anAmount,
            $this->currency()
        );
    }
}
```
Объект `Money` возращаемый функцией `increaseAmountBy`, отличается от объекта `Money` в которым был 
иницирован вызов функции. Это можно наблюдать в приведенных ниж примерах проверов соппоставимости:
```php
<?php
$aMoney = new Money(100, new Currency('USD')); 
$otherMoney = $aMoney->increaseAmountBy(100);

var_dump($aMoney === $otherMoney); // bool(false)

$aMoney = $aMoney->increaseAmountBy(100);
var_dump($aMoney === $otherMoney); // bool(false)
```
### Концептуальное Целое
Может возникнуть вопрос: "Почему бы просто не реализовать что-то похожее как на примере ниже, полностью
избегая необходимости в Объекте Значения?":
```php
class Product
{
    private id; 
    private name;
    /**
    * @var int
    */
    private $amount;
    /**
    * @var string
    */
    private $currency;
    // ...
}
```
У этого подхода есть некоторые значительные недостатки, например, если вы хотите проверить ISO. 
В действительности нет необходимости в том чтобы `Product` отвечал за валидацию ISO валюты `Currency`
(это нарушает первое правило SOLID, Единство Ответственности). Это еще более заметно, если вы
хотите повторно использовать сопутствующую логику в других частях вашего Домена (придерживаясь принципа DRY).

Учитивая эти факторы, описанный пример является идеальным каждидатом для абстрагирования в Объект Значения.
Использование этой бастракции не только дает вам возможность группировать связанные свойства,
но также позволяет создавать концепции более высокого порядка и более конкретный Единый Язык.

>***Упражениние***
> Обсудите с коллегами, может ли email считаться Объектом Значения. Имеет ли значение контект в котором
>используется объект?
### Равенство (эквиваленство) Значения

Как обсуждалось ранее, два Объекта-Значения равны, если содержимое, которое
они измеряют, оценивают, или описывают, одинаково.

Например представьте два объекта `Money` наминалом 1 USD. Можем мы их счетать равными?
В реальном мире две купюры в 1 USD оцениваются одинаково? Скорее всего да.
Возращаясь к коду, расматриваемые два Объекта-Значения являются двумя разными
экземплярами объекта, однако они представляют одниковое значение что делает их подобными.

Касаемо PHP, обычно сравнивают два Объекта-Значения оператором `==`. Если мы изучим
документацию PHP касаемо оператора то увидем интересное поведение:
>При использовании оператора сравнения `==` переменные объекта сравниваются простым способом
>а именно: два экземпляра объекта равно, если они имеют одинаковые атрибуты
>и значения, и являются экземплярами одного и того же класса.
 Данное поведение соответствует нашему формальному описанию Объекта-Значения. 
>Однако, поскольку присутствует предикат точного совпадения имени класса, вам следует 
>быть осторожными при проверке подтипов Объектов-Значения.

К сожалению, даже более строгий оператор `===` нам не поможет:
>При использовании оператора сравнения `===` переменные объекта равны только тогда, когда они
>ссылаются на один и тот же экземпляр одного и того же класса.

Следующий пример должен помочь понять эти тонкие различия:
```php
<?php
    $a = new Currency('USD'); 
    $b = new Currency('USD');
    var_dump($a == $b); // bool(true)
    var_dump($a === $b); // bool(false)
    $c = new Currency('EUR');
    var_dump($a == $c); // bool(false)
    var_dump($a === $c); // bool(false)
```
Решение состоит в том чтобы реализовать метод сравнения в каждом классе
Объектов Значения.
Этот метод выполняет проверку типа и равенства его составных атрибутов.
Сравнение абстрактных типов данных легко реализовать с помощью
 встроенной подсказки типов в PHP. 
 Вы также можете использовать функцию `get_class()` 
 для помощи в проверке сопоставимости при необходимости.
 ### Заменяемость
 Рассмотрим сущность `Product`, которая использует Объект Значение `Money` для хранения цены продукта.
 Дополнительно рассмотрим две сущности `Product` с одинаковой ценой - например 100 USD. Этот сценарий можно
 смоделировать используя два отдельных объекта `Money` или две ссылки указывающих на один Объект Значения.
 
 Совместное использование одного Объекта Значекния может быть рискованым решениемф; измнения затрагивают стоимость
 сразу двух объектов `Product`. Такое поведение можно считать неожиданным побочным эффектом.
 Например, если мы значем что Карлос был принят на работу 20 февраля, и мы знаем, что Кристиан был принят в тот же день,
 мы можем установить дату приема на работу Кристиана такой же, как и у Карлоса. Если Карлос затем меняет
 месяц своей даты найма на май, меняется и дата найма Кристиана. Правильно это или нет, но это не то, чего ожидают люди.
 
 Из-за проблем, выделенных в этом примере, при удерживании ссылки на Объект Значения рекомендуется заменять
 объект целиком, а не изменять его значение:
 ```php
$this−>price = new Money(100, new Currency('USD'));
//...
$this->price = $this->price->increaseAmountBy(200);
``` 

Такое подход повторяет поведения базовых типов PHP (string например). Рассмотрим функцию
`strtolower`. Он возращает новую строку, а не изменяет исходную. Ссылка не используется; вместо этого
возвращается новое значение.

### Поведение без побочных эффектов.
Если мы хотим включить некоторое дополнительнео поведение - например, метод `add` - в наш класс
`Money`, вполне естественно проверить, что входные данные соответствуют любым предварительным условиям
и поддерживаю любую инвариантность. В нашем случае мы хотим добавлять деньги только с одинаковой валютой.:
```php
class Money
{
    // ...
    public function add(Money $money)
    {
        if ($money->currency() !== $this->currency()) {
            throw new InvalidArgumentException();
        }
        $this->amount += $money->amount();
    }
}
```

Если две валюты не совпадают, бросается исключение. В противном случае суммы добавляются. 
Однако этот код некоторые подводные камни. Теперь представьте, что в нашем коде имеется загадочный методы `otherMethod`:
```php
class Banking
{
    public function doSomething()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $this->otherMethod($aMoney);//загадочный метод
        // ...
    }
}
```

Всё будет впорядке, пока по какой-то причине мы не начнем видеть неожиданные рузельтаты в результате выполнения метода
`otherMethod`. Внезапно переменная а `$aMoney` более не является 100 USD. Что произошло?
И что произойдет, если `otherMethod` внутренне использует наш ранее определенный метод `add`?
Возможно, вы не знаете, что метод `add` изменяет состояние экземпляра `Money`. Это то, что мы называем побочным эффектом.
Вы должны избегать побочных эффектов. Вы не должны изменять свои аргументы. Если вы это сделаете,
разработчик, использующий ваши объекты, может столкнуться с непредвиденным поведением. Он будет жаловаться и по делу.

Итак, как мы можем это исправить? Просто - убедившись, что Объект Значения является имутабельным, мы избежим 
подобных проблем. Простым решением может быть возвращение нового экземпляра для каждой потенциально изменяемой 
операции, таких как метод `add`.
```php
class Money
{
// ...
    public function add(Money $money)
    {
        if (!$money->currency()->equals($this->currency())) {
            throw new \InvalidArgumentException();
        }
        return new self(
            $money->amount() + $this->amount(),
            $this->currency()
        );
    }
}
```
С таким простым решением, неизменяемость гарантируется. Каждый раз, когда два экземпляра `Money` используют
метод `add`, возращается новый результирующий экземпляр. Другие классы могут выполнить любое количество изменений,
не затрагивая оригинальную копию. Код без побочных эффектов просто для понимания, легко тестируется и менее
подвержен ошибкам.

## Базовые Типы
Рассмотрим следующий фрагмент кода:
```php
$a = 10;
$b = 10;
var_dump($a == $b);
// bool(true)
var_dump($a === $b);
// bool(true)
$a = 20;
var_dump($a);
// integer(20)
$a = $a + 30;
var_dump($a);
// integer(50);
```

Хотя `$a` и `$b` это разные переменные, хранящиеся в разные местах памяти, при сравнении они одинаковы.
Они имеют одинаковое значение, поэтому мы считаем их равными. Вы можете изменить значение `$a` 
с 10 на 20 в любое время, выбрав новое значение 20 и подменив им 10. Вы можете заменять целочисленыне значения столько,
сколько хотите, без учета предыдущего значения потому что, вы не модифицируете его, вы его заменяете.
Если вы применяете какую либо операцию к ним - например сложение (`$a + $b`) - вы получите другое
новое значение, которое может быть присвоено другой переменной или ранее определенной.
Когда вы передаете `$a` какой либо функции, вы передаете значение, а не ссылку (за исключением тех случае
когда вы намеренно передаете ссылку). Не имеет значение, будет ли `$a` изменено в этой функции, потому что в 
той области видимости откуда был вызван метод у вас все еще будет оригинальная копия. 
Объекты Значения ведут себя как базовые типы.

## Тестирование Объектов Значения

Объекты Значения тестируются так же, как и иные объекты. Тем не менее, неизменяемость и поведение без побочных
эффектов так же должны быть проверены. Решение состоит в том, чтобы создать копию Объекта Значения, который вы тестируете,
перед выполнением каких-либо изменений. Реализацию метод `equal` используйте для проверки подобности.
Выполните действия, которые вы хотите проверить, и подтвердите результаты. Наконец, проверьте, 
что исходны объект и копия по-прежнему равны.

Давайте примененим наши знания на практике и протестируем реализацию нашего метода `add`
 на отсутствие побочных эффектов.
```php
class MoneyTest extends FrameworkTestCase
{
    /**
    * @test
    */
    public function testCopiedMoneyShouldRepresentSameValue()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $copiedMoney = Money::fromMoney($aMoney);
        $this->assertTrue($aMoney->equals($copiedMoney));
    }
    /**
    * @test
    */
    public function testOriginalMoneyShouldNotBeModifiedOnAddition()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $aMoney->add(new Money(20, new Currency('USD')));
        $this->assertEquals(100, $aMoney->amount());
    }
    /**
    * @test
    */
    public function testMoniesShouldBeAdded()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $newMoney = $aMoney->add(new Money(20, new Currency('USD')));
        $this->assertEquals(120, $newMoney->amount());
    }
    // ...
}

```

## Сохранение Объекта Значения

Объекты Значения никогда не хранятся сами по себе; они, как правило, сохраняются как часть Агрегата.
Объекты Значения не должны сохраняться как полные записи, хотя в некоторых случаях это возможно.
Вместо этого лучше использовать шаблоны **Embedded Value** или **Serialize LOB**.
Оба шаблона могут быть использованы при сохранении ваших объектов с использованием Open Source ORM, например
Doctrine, или с поприетарным ORM. Так как Объект Значений являются малыми по размеру, Embedded Value
является хорошим выбором, поскольку этот подход обеспечивает простой способ запроса Сущностей по любому из аттрибутов 
Объектов  Значений. Однако, если для вас не важны запросы по этим полям, реализовать сериализованные стратегии будет проще.

Рассмотрим следующую Сущность `Product` с атрибутами типа `string`: `id`, `name` и `price` (`Money` Объект Значение).
Мы намерено упростили пример сделав `id` строкой, а не Объектом Значения.

```php
class Product
{
    private $productId;
    private $name;
    private $price;
    public function __construct(
        $aProductId,
        $aName,
        Money $aPrice
    ) {
        $this->setProductId($aProductId);
        $this->setName($aName);
        $this->setPrice($aPrice);
    }
    // ...
}
```
Забегая вперед в Главу 10, реализация репозитория для сохранения Сущности может выглядеть так:

```php
$product = new Product(
    $productRepository->nextIdentity(),
    'Domain-Driven Design in PHP',
    new Money(999, new Currency('USD'))
);
$productRepository−>persist(product);
``` 

Теперь рассмотрим как специальные ORM и Doctrine реализуют сохранение Сущности `Product` содержащим 
Объекты Значений. Мы остановимся на применени шаблонов `Embedded Value` и `Serialize LOB`, а
также на различиях между сохранением одного экземпляров Объекта Значения и их коллекций.

> **Почему Doctrine?**
> Doctrine - это великая ORM. Она покрывает 80% задач и требований, которые ставят приложения на PHP.
>У этой ORM отличное сообщество. При правильной настройке она может работать так же или даже лучше, чем 
>сделаныне на заказ ORM (без потери удобства обслуживания). Мы рекомендуем использовать Doctrine в 
>большинстве случаев при работе с Сущностями и безнес-логикой. Это сэкономит вам много времени и нервов.

## Сохранение Простого Объекта Значения.
Для сохранения одного Объекта Значения доступно множество опций. 
Они варьируются от использования Serialize LOB или Embedded Value в качестве стратегии сопоставления, до использования
специального ORM или альтернативы с открытым исходных кодом, такой как Doctrine.
Под специальной ORM мы подразумеваем пользовательскую ORM, разработанная вашей компанией для сохранения Сущностей
в базу данных. В нашем сценарии специальный ORM код будет реализован с использованием библиотеки
[DBAL](https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/).
Согласно [официальной документации](https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/introduction.html) The Doctrine Database Abstraction & Access Layer (DBAL) предлагает 
легкий и тонкий runtime слой вокруг PDO-подобного API и множество дополнительных горизонтальный функций,
самоанализ схемы базы данных и манипулирование через OO API.

### Embedded Value (Встроеное Значение) с помощью специальной ORM
Если мы имеем дело со специальной ORM, использущей шаблон Embedded Value, нам нужно создать поле
в таблице Entity для каждого атрибута Объекта Значения. В этом случае для сохранения Сущности
`Product` требуется два дополнительных столбца - один для стоимости, второй для кода валюты.

```sql
CREATE TABLE `products` (
    id INT NOT NULL,
    name VARCHAR( 255) NOT NULL,
    price_amount INT NOT NULL,
    price_currency VARCHAR( 3) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```   
Если вы используется специальный репозиторий ORM на основе DBAL, назовем его `DbalProductRepository` - 
вы должны позаботиться о создании оператора `INSERT`, привязки параметров и выполнении этого метода.

```php
class DbalProductRepository extends DbalRepository implements ProductRepository
{
    public function add(Product $aProduct)
    {
        $sql = 'INSERT INTO products VALUES (?, ?, ?, ?)' ;
        $stmt = $this->connection()->prepare($sql);
        $stmt->bindValue(1, $aProduct->id());
        $stmt->bindValue(2, $aProduct->name());
        $stmt->bindValue(3, $aProduct->price()->amount());
        $stmt->bindValue(4, $aProduct
                        ->price()->currency()->isoCode());
        $stmt->execute();
        // ...
    }
}

```  
После выполнения этого фрагмента кода для создания Сущностей `Product` и сохранения их, каждый столбец
заполняется необходимой информацией:
```sql
mysql> select * from products \G
*************************** 1. row ***************************
id: 1
name: Domain-Driven Design in PHP
price_amount: 999
price_currency: USD
1 row in set (0.00 sec)
```
Как видите, вы можете сопоставить свои Объекты Значений с параметрами запроса, чтобы сохранить ваши
Объекты Значения в базе данных. Однако, не все так просто, как кажется. Попробуем извлечь сохраненный продукт с 
с соотвествующим Объектом Значения `Money`. Обычно подход заключается в выполнении оператора `SELECT` и 
возврате новой Сущности:
```php
class DbalProductRepository extends DbalRepository implements ProductRepository
{
    public function productOfId($anId)
    {
        $sql = 'SELECT * FROM products WHERE id = ?';
        $stmt = $this->connection()->prepare($sql);
        $stmt->bindValue(1, $anId);
        $res = $stmt->execute();
        // ...
        return new Product(
            $row['id'],
            $row['name'],
            new Money(
                $row['price_amount'],
                new Currency($row['price_currency'])
            )
        );
    }
}

``` 
У этого подхода есть некоторые преимущества. Во-первых, вы можете легко прочитать, шаг за шагом,
каждый необходимый элемент. Во-вторых, вы можете выполнять запросы на основе любых атрибутов Объекта Значения.
Наконец, ваша Сущности будет занимать в базе ровно столько места, сколько ей требуется - не больше и не меньше.

Однако использование собственно-написанной ORM имеет свои недостатки. Как объясняется в главе 6 "События домена",
сущности (в представлении агрегата) должны вызывать событие в конструкторе, если ваш домен занят созданием агрегата.
Если использовать оператор `new`, то событие будет вызываться столько раз, сколько раз агрегат будет получен 
из базы данных.

Это одна из причин почему Doctrine использует внутренние прокси, а так же сериализуещие и 
десериализуещие методы для востановления объекта с его атрибутами в определенном состоянии без использования его
конструктора. Сущность должна быть создана с новым оператором только один раз за время своего существования:

> **Конструкторы**
> В конструкторы не обязательно помещать параметры для каждого атрибута объекта. Подумайте о посте в блоге.
> Конструктор может нуждаться в идентификаторе и заголовке; однако, внутри он может так же установить свой атрибут `status`
> значение _Черновик_. При публикации поста необходимо вызвать метод публикации, чтобы 
> соответствующим образом изменить его статус и установить дату публикации.

Если вы все еще хотите создать свой ORM, будьте готовы решить некоторые фундаментальные проблемы, такие как
События, различные конструкторы, Объекты Значений, отложенная загрузка и другие. Вот почему мы рекомендуем
попробовать Doctrine для приложений реализующих DDD.

Кроме того, в этом случае вам необходимо создать Сущность `DbalProduct`, 
которая наследуется от Сущности `Product` и может востанавливать Сущность из базы данных без использования
оператора `new`, а вместо этого использовать статические методы фабрики.

### Embedded Value (Embeddables) с использованием Doctrine >= 2.5.* 
Последним стабильной версией Doctrine на момент написания книги является 2.5, и она поставляется
с поддержкой сопоставления Объектов Значения, что устраняет необходимость делать это
самостоятельно, как в Doctrine 2.4. С декабря 2015, Doctrine также поддерживает сложенные встраиваемые объекты.

Поскольку классы `Product`, `Money` и `Currency` уже показаны, остается только показать файл настройки
сопоставления Doctrine:
```xml
<?xml version="1.0" encoding="utf-8"?>
<doctrine-mapping
    xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping https://raw.github.com/doctrine/doctrine2/master/doctrine-mapping.xsd">
    <entity
        name="Product"
        table="product">
        <id
            name="id"
            column="id"
            type="string"
            length="255">
            <generator strategy="NONE">
            </generator>
        </id>
        <field
            name="name"
            type="string"
            length="255"
        />
        <embedded
            name="price"
            class="Ddd\Domain\Model\Money"
        />
    </entity>
</doctrine-mapping>
```
В сопоставлении продукта мы определяем цену как переменную экземпляра класса `Money`.
В то же время, `Money` спроектирован с реализацией класса `Currency`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<doctrine-mapping
    xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://doctrine-project.org/schemas/orm/doctrine-mapping
    https://raw.github.com/doctrine/doctrine2/master/doctrine-mapping.xsd">
    <embeddable
        name="Ddd\Domain\Model\Money">
        <field
            name="amount"
            type="integer"
        />
        <embedded
            name="currency"
            class="Ddd\Domain\Model\Currency"
        />
    </embeddable>
</doctrine-mapping>
```                  
Наконец, пришло время показать конфигурацию сопоставления для нашего Объекта Значения `Currency`:
```xml
<?xml version="1.0" encoding="utf-8"?>
<doctrine-mapping
    xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://doctrine-project.org/schemas/orm/doctrine-mapping
        https://raw.github.com/doctrine/doctrine2/master/doctrine-mapping.xsd">
    <embeddable
        name="Ddd\Domain\Model\Currency">
        <field
            name="iso"
            type="string"
            length="3"
        />
    </embeddable>
</doctrine-mapping>
```
Как видите, приведенный выше код имеет стандартное встраиваемое определение с одним строковым полем,
содержащим код ISO. Этот подход является самым простым способом использования встраиваемых объектов и 
гораздо эффективнее. По умолчанию, Doctrine присваиваем имена вашим столбцам, добавляя к ним префикс, используя имя
Объекта Значения. Вы можете изменить это поведение в соответствии с вашими потребностями, отредактировав
атрибут `column-prefix` в xml нотации.

## Serialized LOB и специальная ORM
Если поиск по атрибутам Объекта Значения не нужно, можно рассмотреть
еще один шаблон: the Serialize LOB (Сериализованный Большой Объект).
Этот шаблон работает путем сериализации всего Объекта Значения в строковый
формат, который можно легко сохранить и извлечь. Наиболее существенное
различие между этим решением и альтернативой встраивания объекта заключается в том,
что в последнем варианте весь объект занимает лиш одну колонку в таблице.

```sql
CREATE TABLE ` products` (
    id INT NOT NULL,
    name VARCHAR( 255) NOT NULL,
    price TEXT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```
Для сохранения Сущности `Product` при использовании этого подхода,
требуется изменение в `DbalProductRepository`. Объект Значение
`Money` должно быть сереализовано в строку перед сохранением Сущности.

```php
class DbalProductRepository extends DbalRepository implements ProductRepository
{
    public function add(Product $aProduct)
    {
        $sql = 'INSERT INTO products VALUES (?, ?, ?)';
        $stmt = this->connection()->prepare(sql); 
        $stmt->bindValue(1, aProduct−>id()); 
        $stmt->bindValue(2, aProduct−>name()); 
        $stmt->bindValue(3, $this−>serialize($aProduct->price()));
        // ...
    }
    private function serialize($object)
    {
        return serialize($object);
    }
}
```
Теперь посмотрим, как наш `Product` представлен в базе данных.
Тип столбца `price` TEXT, в ней хранится сериализованный объект `Money`,
представлющий 9.99USD
```sql
mysql > select * from products \G
*************************** 1.row***************************
id : 1
name : Domain-Driven Design in PHP
price : O:22:"Ddd\Domain\Model\Money":2:{s:30:"Ddd\Domain\Model\\
Money amount";i :
999;s:32:"Ddd\Domain\Model\Money currency";O : 25:"Ddd\Domain\Model\\
Currency":1:{\
s:34:" Ddd\Domain\Model\Currency isoCode";s:3:"USD";}}1 row in set(\ 0.00
sec)
```
Этот подход работает. Однако он не рекомендуется из-за проблем,
возникающих при рефакторинге классов в вашем коде. Можете ли вы
представить проблемы с которыми столкнемся, если решим переименовать
наш класс `Money`? А какие изменения потребуются в базе данных при перемещении
класс `Money` в другое пространство имен? Другой сложностью, как говорилось ранее,
является отсутствие возможности запроса по атрибутам Объекта Значения.
Неважно, используете вы Doctrine или нет; написать запрос, чтобы
получить продукты дешевле, скажем, 200 долларов, практически невозможно.

Проблема запроса по атрибутам Объекта Значения может быть решена только
при подходе Embedded Values. Однако проблемы рефакторинга могут быть
решены с помощью специальной библиотеки для процессов сериализации.

### Улучшенная сериализация с помощью JMS Serialize
При сериализации / десериализации нативных PHP стратегий, возникает проблема,
связанная с рефакторингом классов и пространств имен. Один из альтернативных вариантов использовать собственный
механизм сериализации. Однако есть еще один предпочтительный подход: использованием библиотеки 
сериализатора с открытым исходным кодом, такую как `JMS Serializer`. Давайте рассмотрим пример
его применения при сериализации объекта `Money`:
```php
$myMoney = new Money(999, new Currency('USD'));

$serializer = JMS\Serializer\SerializerBuilder::create()->build();
$jsonData = $serializer−>serialize($myMoney, 'json');
```
Процес десериализации объекта так же прост:
```php
$serializer = JMS\Serializer\SerializerBuilder::create()->build();
// ...
$myMoney = $serializer−>deserialize(jsonData, 'Ddd', 'json');
```
В этом примере вы можете проводить рефакторинг своего класса `Money` без необходимости обновления базы данных.
`JMS Serializer` может быть использован в множестве других сценариев - например, при работе с REST API.
Важной особенностью является возможность указать, какие атрибуты объекта должн ыбыть пропущены в процессе сериализации - например, пароль.

## Serialized LOB с использвоанием Doctrine
В `Doctrine` существуют различные способы сериализации объектов, для их дальнейшего сохранения.

### Doctrine Object Mapping Type
`Doctrine` поддерживает шаблон `Serialize LOB`. Существует множество предопределенных типов сопоставления,
которые можно использовать для сопоставления атрибутов Сущности со столбцами базы данных и таблиц. Одним
из таких сопоставлений является тип объекта, который сопоставляет SQL CLOB с PHP объектом при использоании
`serialize()` и `unserialize()`.

Согласно документации [`Doctrine DBAL 2`](https://www.doctrine-project.org/projects/doctrine-orm/en/2.7/reference/basic-mapping.html), тип `object`:
>Отображает и преобразует данные объекта на основе сериализации PHP. Если вам необходимо сохранить точное
>представление данных вашего объекта, вам следует рассмотреть возможность использования этого типа,
>поскольку он использует сериализации для представления точной копии вашего объекта в виде строки в базе данных.
>Значения, извлеченные из базы данных, всегда преобразуются в тип объекта PHP с использованием десериализации
>или null-значение, если данные отсутствуют.
>
>Этот тип всегда будет привязан к текстовому типу используемой базы данных, поскольку нет способа сохранить
>представление объекта PHP в базе данных в его исходном виде. Кроме того, для этого типа требуется подсказка в виде
>комментария к столбцу SQL, чтобы его можно было корректно восстановить. Doctrine не может правильно востановить объект, 
>используя решения, которые не поддерживают комментарии к столбцам, и вместо этого будет
>возвращать текстовое значение.
>
>Поскольу встроенный тип `text` в PostgreSql не поддерживает NULL байт, при десирализации будет возникать ошибка.
>Решением может служить использование `serialize()/unserialize()` и `base64_encode()/base64_decode()`
>с дальнейшим хранением результата в текстовом поле.

Рассмотрим возможное XML сопоставление для Сущности `Product` с использованием типа `object`
```xml
<?xml version="1.0" encoding="utf-8"?>
<doctrine-mapping
    xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://doctrine-project.org/schemas/orm/doctrine-mapping
    https://raw.github.com/doctrine/doctrine2/master/doctrine-mapping.xsd">
    <entity
        name="Product"
        table="products">
        <id
            name="id"
            column="id"
            type="string"
            length="255">
            <generator strategy="NONE">
            </generator>
        </id>
        <field
            name="name"
            type="string"
            length="255"
        />
        <field
            name="price"
            type="object"
        />
    </entity>
</doctrine-mapping>
```
Ключевым дополнением является `type="object`, которое сообщает Doctrine, что мы собираемся использовать сопоставление объектов.
Рассмотрим, как мы можем создать и сохранить Сущность `Product`, используя Doctrine:
```php
// ...
$em−>persist($product);
$em−>flush($product);
```
Проверим, если мы теперь запросим нашу Сущность `Product` из базы данных, вернется ли он нам в корректном
состоянии:
```php
// ...
$repository = $em->getRepository('Ddd\\Domain\\Model\\Product');
$item = $repository->find(1);
var_dump($item);
/*
class Ddd\Domain\Model\Product#177 (3) {
    private $productId => int(1)
    private $name => string(41) "Domain-Driven Design in PHP"
    private $money => class Ddd\Domain\Model\Money#174 (2) {
        private $amount => string(3) "100"
        private $currency => class Ddd\Domain\Model\Currency#175 (1){
            private $isoCode => string(3) "USD"
        }
    }
}
* /
```
И последнее, но неменее важно, документация гласит:
>Типы `object` сравниваются по ссылке, а не по значению. Doctrine обновляет это значение, если ссылка изменилась, и, 
>следовательно, ведет себя так, как будто объекты являются неизменяемыми.

Этот подход страдает от тех же проблем рефаторинга, что и рассмотренная ранее специальная ORM. Сопоставление типа
`object` использует `serialize/unserialize`. Как насчет использования собственной сериализации?

### Doctrine Пользовательские Типы
Другим вариантом является сохранение Объекта Значения с помощью пользовательского типа Doctrine.
Пользовательский Тип добавляет новый тип сопоставления в Doctrine - токой, который описывает пользовательское
преобразование между полем Сущности и его представлением в базе данных.

В [документации](https://www.doctrine-project.org/projects/doctrine-orm/en/2.7/cookbook/custom-mapping-types.html#custom-mapping-types) написано:
>Простое преобразование всех типов для хранение в базе данных используемое в Doctrine вовсе не универсально.
>Вы можете определить свои собственные Doctrine Mapping Types унаследовавшись от `Doctrine\DBAL\Types\Type`.
>Вы должны реализовать 4 метода, чтобы все заработало.

Тип `object` при сериализации используется такая информация как класс объекта, что затрудняет безопасный рефакторинг.

Давайте попробуем улучшить это решение. Подумаем о собственном процессе сериализации, который может устранить проблему.

Одним из таких способов может быть сохранение Объекта Значения `Money` в базе данных в виде строки, закодированной в форматы amount|isoCode.
```php
use Ddd\Domain\Model\Currency;
use Ddd\Domain\Model\Money;
use Doctrine\DBAL\Types\TextType;
use Doctrine\DBAL\Platforms\AbstractPlatform;

class MoneyType extends TextType
{
    const MONEY = 'money';
    public function convertToPHPValue(
        $value,
        AbstractPlatform $platform
    ) {
        $value = parent::convertToPHPValue($value, $platform);
        $value = explode('|', $value);
        return new Money(
            $value[0],
            new Currency($value[1])
        );
    }

    public function convertToDatabaseValue(
        $value,
        AbstractPlatform $platform
    ) {
        return implode(
            '|',
            [
                $value->amount(),
                $value->currency()->isoCode()
            ]
        );
    }
    public function getName()
    {
        return self::MONEY;
    }
}
```
Используя Doctrine, вам необходимо зарегистрироваться все пользовательские типы. Обычно для этого
используется фабрика `EntityManagerFactory` которая пораждает `EntityManager`.

Кроме того, вы можете выполнить этот шаг на этапе загрузки приложения:
```php
use Doctrine\DBAL\Types\Type;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Tools\Setup;
class EntityManagerFactory
{
    public function build()
    {
        Type::addType(
            'money',
            'Ddd\Infrastructure\Persistence\Doctrine\Type\MoneyType'
        );

        return EntityManager::create(
            [
                'driver' => 'pdo_mysql',
                'user' => 'root',
                'password' => '',
                'dbname' => 'ddd',
            ],
            Setup::createXMLMetadataConfiguration(
                [__DIR__.'/config'],
                true
            )
        );
    }
}
```
Теперь нам нужно указать в настройках сопоставления, что мы хотим использовать наш пользовательский тип:
```xml
<?xml version = "1.0" encoding = "utf-8"?>
<doctrine-mapping>
    <entity
        name = "Product"
        table = "product">

        <!-- ... -->
        <field
            name = "price"
            type = "money"
        />
    </entity>
</doctrine-mapping>
```
Давайте проверим базу данных чтобы увидеть как сохраняется `Money` в этом случае.
```mysql
mysql> select * from products \G
*************************** 1. row***************************
id: 1
name: Domain-Driven Design in PHP
price: 999|USD
1 row in set (0.00 sec)
```
Этот подход явно лучше про сравнению с предыдущим с точки зрения будущего рефаторинга.
Однако возможности поиска по значения остаются ограниченными из-за формата столбца.
С помощью пользовательских типов Doctrine вы можете немного улучшить ситуацию, но это 
все еще не лучший вариантов для построения DQL запросов. С дополнительной информацией можете
ознакомиться на странице [Custom Mapping Types](https://www.doctrine-project.org/projects/doctrine-orm/en/2.7/cookbook/custom-mapping-types.html#custom-mapping-types)

