Глава 3. Объекты-Значения (The Value Objects)
==

Объекты-Значения являются фундаментальным строительным блоком DDD, и они используются для моделирования концепции вашего 
Единого Языка в коде. Объект Значения - это не просто вещь в вашем домене - 
он измеряет, определяем количество или описывает что-то. Объекты Значения могут рассматриваться
как небольшие простые объекты, такие как деньги или диапозон дат, равенство
которых основано не на идентификаторе, а на содержании.

Например, цена продукта может быть смоделирована с использованием Объекта Значения.
В данном случае это не вещь, а ценность, которая позволяет нам измерить, сколько
денег стоит продукт. Объем памяти для таких объектов легко определяется (рассчитывается
по составным частям), а накладных расходов очень мало. В результате создание нового экземпляра
предпочтительнее повторного использования ссылок, даже если Объект-Значения использоуется для
предоставления одного и того же значения. Равенство проверяется на основе сопоставимости
всех полей экземпляров.

## Определение
Уорд Каннингем (Ward Cunningham) дает следующее [определение](http://c2.com/cgi/wiki?ValueObject) Объекту Значения:
>Это мера или описание чего-либо. Примерами Объектов Значения являются такие вещи, как числа, даты, денежные суммы и строки.
>Обычно это не большие Объекты, которые используются довольно широко.
>Их идентичность основана на их состояни, а не на идентификаторе Объекта. 
>Таким образом, вы можете иметь несколько копий одного концептуального Объекта Значения.
>Каждая банкнота достоинством 5 долларов имеет свою собственную идентификацию (благодаря
>своему серийному номеру), но экономия денежных средств зависит от того, что
>каждая банкнота достоинством в 5 долларов имеет ту же стоимость, что и любая другая банкнота в 5 долларов.

Мартин Фаулер дает следующее [определение](http://martinfowler.com/bliki/ValueObject.html) Объекту Значения:
>Это маленький Объект, такой как деньги или диапозон дат. Их ключевое свойство
>заключается в том, что они следуют семантике значений, а не ссылочной семантике.
>Мы можем так утверждать, потому что их понятие равенства не основано на идентификаторе,
>вместо этого два Объекта Значения равны, если все их поля равны. 
>Хотя все поля равны, вам не нужно сравнивать все поля, если подмножество уникально - 
>например, кодов валюты для объектов валюты достаточно чтобы проверить равенство.
>Общая эвристика заключается в том, что Объекты Значения должны быть полностью неизменными.
>Если вы хотите изменить объект значения, вы должны заменить объект новым и не иметь
>возможности обновлять значения самого Объекта Значения. Обновляемые Объекты Значения приводят
>к проблемам с наложением имен.

Примерами Объектов Значения являются числа, текстовые строки, даты, время, полное имя человека
>***Упражнение***
>Попробуйте найти дополнительные Объекты Значения в вашем текущем Домене.

## Объекты значения vs Сущности

Рассмотрим следующие примеры из [Википедии](http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD), чтобы лучше понять разница между
Объектами Значениями и Сущностями:
- Объект Значения. Когда люди обменивают долларовые банкноты, они обычно не 
различают каждый уникальную купюру; они обеспокоены только номинальной стоимостью
долларовой банкноты. В этом контексте далларовые банкноты ялвяются Объектами Значения.
Тем не менее, Федеральный Резерв может быть обеспокоен каждым уникальным счетом; в этом контексте
каждый счет был бы сущностью.
- Сущность. Большинство авиакомпаний различают каждое место уникально на каждом рейсе.
Каждое место в данном контексте является сущностью. Однако Southwest Airlines, EasyJet и
Ryanair не различают каждое место; все места одинаковые. В этом контексте место на самом деле является
Объектом Значения.

>***Упражнение***
>Подумайте о понятии адреса (индекс, улица, номер дома и т.д.). Каков возможный
>контекст, в котором адрес может быть смоделирован как сущность, а не как объект значения? 
>Обсудите ваши выводы с коллегами.

## Пример "Валюта" и "Стоимость"

Объекты Значения "Валюта" и "Денежная Стоимость", вероятно, являются наиболее
часто используемыми примерами для объяснения Объектов Значения, благодаря 
[патерну "Деньги" (Money)](http://martinfowler.com/eaaCatalog/money.html).
Этот шаблон проектирования предоставляет решение для моделирования задачи, которая позволяет
избежать проблемы округления с плавающей запятой, что, в свою очередь, позволяет выполнять
детерминированные вычисления.

В реальном мире валюта описывает денежные единицы так же, как метры и ярды описывают единицы расстояния.
Каждая валюта представлена трехбуквенным ISO кодом в верхнем регистре:
```php
class Currency
{
    private $isoCode;
    public function __construct($anIsoCode)
    {
        $this->setIsoCode($anIsoCode);
    }

    private function setIsoCode($anIsoCode)
    {
        if (!preg_match('/^[A-Z]{3}$/', $anIsoCode)) {
            throw new InvalidArgumentException();
        }
        $this->isoCode = $anIsoCode;
    }

    public function isoCode()
    {
        return $this->isoCode;
    }
}
```
Одна из основных целей Объектов Значения так же являются святым Граалем ООП: инкапсуляция.
Следуя этому шаблону, вы получите выделенное место для размещения всей проверки,
логики сравнения и поведения для данной концепции.

>***Дополнительные Проверки Валюты***
>В предыдущем примере кода мы можем построить валюту с кодом ISO равным ААА.
>Это не валидно, валюты с такой кодировкой не существует. Напишите более конкретное правило,
>которое проверит, действителен ли код ISO. Полный список действительный валютных кодов ISO 
>можно найти 
>[здесь](https://www.xe.com/iso4217.php). Если вам нужна помощь, взгляните на библиотеку 
>[Money Packagist](https://github.com/moneyphp/money)

Деньги используются для измерения определенной суммы валюты. Они моделируются с 
помощью суммы и валюты. Сумма, в случае паттерна Money, реализуется с использованием
целочисленного представления наименее значимой доли валюты - например, в центах долларов США или 
копеек в рублях России.

В качестве бонуса вы также можете заметить, что мы используем самоинкапсуляцию
для установки кода ISO, которая центарлизует изменения в самом Объекте Значения:
```php
class Money
{
    private $amount; 
    private $currency;

    public function __construct($anAmount, Currency $aCurrency)
    {
        $this->setAmount($anAmount);
        $this->setCurrency($aCurrency);
    }

    private function setAmount($anAmount)
    {
        $this->amount = (int) $anAmount;
    }

    private function setCurrency(Currency $aCurrency)
    {
        $this->currency = $aCurrency;
    }

    public function amount()
    {
        return $this->amount;
    }

    public function currency()
    {
        return $this->currency;
    }
}
```
Теперь, когда вы знаете формальное определение Объектов Значений, давайте
углубимся в тот мощной функционал который они предоставляют.

## Характеристики

При моделированние концепции Единого Языка вашего Домена, вы всегда должны отдавать
предпочтение Объектам Значения, а не Сущностям. Объекты Значения проще создавать, тестировать, 
использовать и поддерживать.

Исходя из этого, вы можете определить, может ли рассматриваемая концепция моделироваться как 
Объект Значения, если:

- Он измеряет, оценивает или описывает объект предметной области.
- Он может быть имутабельным (неизменяемым).
- Он моделирует концептуальное целое, объединяя связанные атрибуты в единое целое.
- Он может быть сравнен с другим таким же объектом через равенство всех его аттрибутов.
- Он полностью заменяется при изменении способа измерения или описания.
- Он предоставляет связанным с ним объектам функцию без побочных эффектов.

### Измерение, Оценивание, или Описание
Как говорилось выше, Объект Значения не должен рассматриваться как вещь в вашем Домене.
В качестве значения Объект Значения измеряет, оценивает или описывает концепцию в Домене.

В нашем примере объект `Currency` описывает тип объекта `Money`. Объект `Money` измеряет
или количественно оценивает единицы данной валюты.

### Имутабельность
Это один из важнейших аспектов для усвоения. Объекты Значения не могут быть измнены в 
течении всего периода их использования. Благодаря этой имутабельности Объект Значения
легко создавать и тестировать, они не содержат нежелательных/неожиданных побочных эффектов.
Таким образом, Объекты Значения должны создаваться через их конструкторы. 
Чтобы создать его, вы обычно передаете необходимые типы притивов или другие Объект Значения
через конструктор.

Объекты Знечения всегда находятся в валидном состоянии; Вот почему мы создаем их за один
шаг. Пустые конструкторы с несколькими сеттерами или геттерами переносят 
ответственность за создание на клиента что приводит к Анемичность Доменой Модели, что считается антипатерном.

Также важно отметить, что не рекомендуется хранить ссылки на Сущности внутри ваших Объектов Значения.
Сущности являются изменяемыми, и хранение ссылок на них может привести к 
нежелательным побочным эффектам в Объекте Значения.

В языках с `перегрузкой методов` таких как Java, вы можете создавать несколько
конструкторов с одинаковыми именами. Каждому из этих конструкторов предоставляются
различные входные параметры для создания одного и того же типа результирующего объекта.
В PHP мы можем реализовать аналогичную возможность с помощью фабричных методов.
Эти специфичные фабричные методы также известны как семантические конструкторы.
Основная цель `fromMoney` метода предоставить больше контекстуального значения, чем 
простой конструктор. Более радикальные подходы предлагают сделать метод
`__construct` приватным и для создания объекта используют семантический конструктор.

В нашем объекте `Money` мы могли бы реализовать несколько полезных 
фабричных методово, какие как:
 ```php
class Money
{
    // ...
    public static function fromMoney(Money $aMoney)
    {
        return new self(
            $aMoney->amount(),
            $aMoney->currency()
        );
    }
    public static function ofCurrency(Currency $aCurrency)
    {
        return new self(0, $aCurrency);
    }
}
```
Использую ключевое слово `self`, мы не связываем код с именем класса. 
Таким образом, изменение имени класса или пространства имен не повлияет на работоспособность
фабричных методов. Эта маленькая деталь реализации поможет нам при рефакторинге на более
познем этапе.

>***`static` или `self`***
>Использование `static` вместо `self` может привести к нежелательным проблемам, когда Объект Значения
>наследуется от другого Объекта Значения.

Учитывая имутабельность, нам нужно понять как обрабатывать действия изменения объекта, которые
обычно встречаются в контексте состояния. Если нам требуется измненеия состояния, мы должны вернуть
новой экземпляр Объекта Значения в котором учтено это измненение. Например если мы хотим увеличить
сумму Объекта Значения `Money`, мы вместо того чтобы этому объекту присвоить новое значени должны создать и вернуть новый объект.

К счастью, следовать этому правилу достаточно просто:
```php
class Money
{
    // ...
    public function increaseAmountBy($anAmount)
    {
        return new self(
            $this->amount() + $anAmount,
            $this->currency()
        );
    }
}
```
Объект `Money` возращаемый функцией `increaseAmountBy`, отличается от объекта `Money` в которым был 
иницирован вызов функции. Это можно наблюдать в приведенных ниж примерах проверов соппоставимости:
```php
<?php
$aMoney = new Money(100, new Currency('USD')); 
$otherMoney = $aMoney->increaseAmountBy(100);

var_dump($aMoney === $otherMoney); // bool(false)

$aMoney = $aMoney->increaseAmountBy(100);
var_dump($aMoney === $otherMoney); // bool(false)
```
### Концептуальное Целое
Может возникнуть вопрос: "Почему бы просто не реализовать что-то похожее как на примере ниже, полностью
избегая необходимости в Объекте Значения?":
```php
class Product
{
    private id; 
    private name;
    /**
    * @var int
    */
    private $amount;
    /**
    * @var string
    */
    private $currency;
    // ...
}
```
У этого подхода есть некоторые значительные недостатки, например, если вы хотите проверить ISO. 
В действительности нет необходимости в том чтобы `Product` отвечал за валидацию ISO валюты `Currency`
(это нарушает первое правило SOLID, Единство Ответственности). Это еще более заметно, если вы
хотите повторно использовать сопутствующую логику в других частях вашего Домена (придерживаясь принципа DRY).

Учитивая эти факторы, описанный пример является идеальным каждидатом для абстрагирования в Объект Значения.
Использование этой бастракции не только дает вам возможность группировать связанные свойства,
но также позволяет создавать концепции более высокого порядка и более конкретный Единый Язык.

>***Упражениние***
> Обсудите с коллегами, может ли email считаться Объектом Значения. Имеет ли значение контект в котором
>используется объект?
### Равенство (эквиваленство) Значения

Как обсуждалось ранее, два Объекта-Значения равны, если содержимое, которое
они измеряют, оценивают, или описывают, одинаково.

Например представьте два объекта `Money` наминалом 1 USD. Можем мы их счетать равными?
В реальном мире две купюры в 1 USD оцениваются одинаково? Скорее всего да.
Возращаясь к коду, расматриваемые два Объекта-Значения являются двумя разными
экземплярами объекта, однако они представляют одниковое значение что делает их подобными.

Касаемо PHP, обычно сравнивают два Объекта-Значения оператором `==`. Если мы изучим
документацию PHP касаемо оператора то увидем интересное поведение:
>При использовании оператора сравнения `==` переменные объекта сравниваются простым способом
>а именно: два экземпляра объекта равно, если они имеют одинаковые атрибуты
>и значения, и являются экземплярами одного и того же класса.
 Данное поведение соответствует нашему формальному описанию Объекта-Значения. 
>Однако, поскольку присутствует предикат точного совпадения имени класса, вам следует 
>быть осторожными при проверке подтипов Объектов-Значения.

К сожалению, даже более строгий оператор `===` нам не поможет:
>При использовании оператора сравнения `===` переменные объекта равны только тогда, когда они
>ссылаются на один и тот же экземпляр одного и того же класса.

Следующий пример должен помочь понять эти тонкие различия:
```php
<?php
    $a = new Currency('USD'); 
    $b = new Currency('USD');
    var_dump($a == $b); // bool(true)
    var_dump($a === $b); // bool(false)
    $c = new Currency('EUR');
    var_dump($a == $c); // bool(false)
    var_dump($a === $c); // bool(false)
```
Решение состоит в том чтобы реализовать метод сравнения в каждом классе
Объектов Значения.
Этот метод выполняет проверку типа и равенства его составных атрибутов.
Сравнение абстрактных типов данных легко реализовать с помощью
 встроенной подсказки типов в PHP. 
 Вы также можете использовать функцию `get_class()` 
 для помощи в проверке сопоставимости при необходимости.
 ### Заменяемость
 Рассмотрим сущность `Product`, которая использует Объект Значение `Money` для хранения цены продукта.
 Дополнительно рассмотрим две сущности `Product` с одинаковой ценой - например 100 USD. Этот сценарий можно
 смоделировать используя два отдельных объекта `Money` или две ссылки указывающих на один Объект Значения.
 
 Совместное использование одного Объекта Значекния может быть рискованым решениемф; измнения затрагивают стоимость
 сразу двух объектов `Product`. Такое поведение можно считать неожиданным побочным эффектом.
 Например, если мы значем что Карлос был принят на работу 20 февраля, и мы знаем, что Кристиан был принят в тот же день,
 мы можем установить дату приема на работу Кристиана такой же, как и у Карлоса. Если Карлос затем меняет
 месяц своей даты найма на май, меняется и дата найма Кристиана. Правильно это или нет, но это не то, чего ожидают люди.
 
 Из-за проблем, выделенных в этом примере, при удерживании ссылки на Объект Значения рекомендуется заменять
 объект целиком, а не изменять его значение:
 ```php
$this−>price = new Money(100, new Currency('USD'));
//...
$this->price = $this->price->increaseAmountBy(200);
``` 

Такое подход повторяет поведения базовых типов PHP (string например). Рассмотрим функцию
`strtolower`. Он возращает новую строку, а не изменяет исходную. Ссылка не используется; вместо этого
возвращается новое значение.

### Поведение без побочных эффектов.
Если мы хотим включить некоторое дополнительнео поведение - например, метод `add` - в наш класс
`Money`, вполне естественно проверить, что входные данные соответствуют любым предварительным условиям
и поддерживаю любую инвариантность. В нашем случае мы хотим добавлять деньги только с одинаковой валютой.:
```php
class Money
{
    // ...
    public function add(Money $money)
    {
        if ($money->currency() !== $this->currency()) {
            throw new InvalidArgumentException();
        }
        $this->amount += $money->amount();
    }
}
```

Если две валюты не совпадают, бросается исключение. В противном случае суммы добавляются. 
Однако этот код некоторые подводные камни. Теперь представьте, что в нашем коде имеется загадочный методы `otherMethod`:
```php
class Banking
{
    public function doSomething()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $this->otherMethod($aMoney);//загадочный метод
        // ...
    }
}
```

Всё будет впорядке, пока по какой-то причине мы не начнем видеть неожиданные рузельтаты в результате выполнения метода
`otherMethod`. Внезапно переменная а `$aMoney` более не является 100 USD. Что произошло?
И что произойдет, если `otherMethod` внутренне использует наш ранее определенный метод `add`?
Возможно, вы не знаете, что метод `add` изменяет состояние экземпляра `Money`. Это то, что мы называем побочным эффектом.
Вы должны избегать побочных эффектов. Вы не должны изменять свои аргументы. Если вы это сделаете,
разработчик, использующий ваши объекты, может столкнуться с непредвиденным поведением. Он будет жаловаться и по делу.

Итак, как мы можем это исправить? Просто - убедившись, что Объект Значения является имутабельным, мы избежим 
подобных проблем. Простым решением может быть возвращение нового экземпляра для каждой потенциально изменяемой 
операции, таких как метод `add`.
```php
class Money
{
// ...
    public function add(Money $money)
    {
        if (!$money->currency()->equals($this->currency())) {
            throw new \InvalidArgumentException();
        }
        return new self(
            $money->amount() + $this->amount(),
            $this->currency()
        );
    }
}
```
С таким простым решением, неизменяемость гарантируется. Каждый раз, когда два экземпляра `Money` используют
метод `add`, возращается новый результирующий экземпляр. Другие классы могут выполнить любое количество изменений,
не затрагивая оригинальную копию. Код без побочных эффектов просто для понимания, легко тестируется и менее
подвержен ошибкам.

## Базовые Типы
Рассмотрим следующий фрагмент кода:
```php
$a = 10;
$b = 10;
var_dump($a == $b);
// bool(true)
var_dump($a === $b);
// bool(true)
$a = 20;
var_dump($a);
// integer(20)
$a = $a + 30;
var_dump($a);
// integer(50);
```

Хотя `$a` и `$b` это разные переменные, хранящиеся в разные местах памяти, при сравнении они одинаковы.
Они имеют одинаковое значение, поэтому мы считаем их равными. Вы можете изменить значение `$a` 
с 10 на 20 в любое время, выбрав новое значение 20 и подменив им 10. Вы можете заменять целочисленыне значения столько,
сколько хотите, без учета предыдущего значения потому что, вы не модифицируете его, вы его заменяете.
Если вы применяете какую либо операцию к ним - например сложение (`$a + $b`) - вы получите другое
новое значение, которое может быть присвоено другой переменной или ранее определенной.
Когда вы передаете `$a` какой либо функции, вы передаете значение, а не ссылку (за исключением тех случае
когда вы намеренно передаете ссылку). Не имеет значение, будет ли `$a` изменено в этой функции, потому что в 
той области видимости откуда был вызван метод у вас все еще будет оригинальная копия. 
Объекты Значения ведут себя как базовые типы.

## Тестирование Объектов Значения

Объекты Значения тестируются так же, как и иные объекты. Тем не менее, неизменяемость и поведение без побочных
эффектов так же должны быть проверены. Решение состоит в том, чтобы создать копию Объекта Значения, который вы тестируете,
перед выполнением каких-либо изменений. Реализацию метод `equal` используйте для проверки подобности.
Выполните действия, которые вы хотите проверить, и подтвердите результаты. Наконец, проверьте, 
что исходны объект и копия по-прежнему равны.

Давайте примененим наши знания на практике и протестируем реализацию нашего метода `add`
 на отсутствие побочных эффектов.
```php
class MoneyTest extends FrameworkTestCase
{
    /**
    * @test
    */
    public function testCopiedMoneyShouldRepresentSameValue()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $copiedMoney = Money::fromMoney($aMoney);
        $this->assertTrue($aMoney->equals($copiedMoney));
    }
    /**
    * @test
    */
    public function testOriginalMoneyShouldNotBeModifiedOnAddition()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $aMoney->add(new Money(20, new Currency('USD')));
        $this->assertEquals(100, $aMoney->amount());
    }
    /**
    * @test
    */
    public function testMoniesShouldBeAdded()
    {
        $aMoney = new Money(100, new Currency('USD'));
        $newMoney = $aMoney->add(new Money(20, new Currency('USD')));
        $this->assertEquals(120, $newMoney->amount());
    }
    // ...
}

```

## Сохранение Объекта Значения

Объекты Значения никогда не хранятся сами по себе; они, как правило, сохраняются как часть Агрегата.
Объекты Значения не должны сохраняться как полные записи, хотя в некоторых случаях это возможно.
Вместо этого лучше использовать шаблоны **Embedded Value** или **Serialize LOB**.
Оба шаблона могут быть использованы при сохранении ваших объектов с использованием Open Source ORM, например
Doctrine, или с поприетарным ORM. Так как Объект Значений являются малыми по размеру, Embedded Value
является хорошим выбором, поскольку этот подход обеспечивает простой способ запроса Сущностей по любому из аттрибутов 
Объектов  Значений. Однако, если для вас не важны запросы по этим полям, реализовать сериализованные стратегии будет проще.

Рассмотрим следующую Сущность `Product` с атрибутами типа `string`: `id`, `name` и `price` (`Money` Объект Значение).
Мы намерено упростили пример сделав `id` строкой, а не Объектом Значения.

```php
class Product
{
    private $productId;
    private $name;
    private $price;
    public function __construct(
        $aProductId,
        $aName,
        Money $aPrice
    ) {
        $this->setProductId($aProductId);
        $this->setName($aName);
        $this->setPrice($aPrice);
    }
    // ...
}
```
Забегая вперед в Главу 10, реализация репозитория для сохранения Сущности может выглядеть так:

```php
$product = new Product(
    $productRepository->nextIdentity(),
    'Domain-Driven Design in PHP',
    new Money(999, new Currency('USD'))
);
$productRepository−>persist(product);
``` 

Теперь рассмотрим как специальные ORM и Doctrine реализуют сохранение Сущности `Product` содержащим 
Объекты Значений. Мы остановимся на применени шаблонов `Embedded Value` и `Serialize LOB`, а
также на различиях между сохранением одного экземпляров Объекта Значения и их коллекций.

> **Почему Doctrine?**
> Doctrine - это великая ORM. Она покрывает 80% задач и требований, которые ставят приложения на PHP.
>У этой ORM отличное сообщество. При правильной настройке она может работать так же или даже лучше, чем 
>сделаныне на заказ ORM (без потери удобства обслуживания). Мы рекомендуем использовать Doctrine в 
>большинстве случаев при работе с Сущностями и безнес-логикой. Это сэкономит вам много времени и нервов.

## Сохранение Простого Объекта Значения.
