Глава 3. Объекты-Значения (The Value Objects)
==

Объекты-Значения являются фундаментальным строительным блоком DDD, и они используются для моделирования концепции вашего 
Единого Языка в коде. Объект Значения - это не просто вещь в вашем домене - 
он измеряет, определяем количество или описывает что-то. Объекты Значения могут рассматриваться
как небольшие простые объекты, такие как деньги или диапозон дат, равенство
которых основано не на идентификаторе, а на содержании.

Например, цена продукта может быть смоделирована с использованием Объекта Значения.
В данном случае это не вещь, а ценность, которая позволяет нам измерить, сколько
денег стоит продукт. Объем памяти для таких объектов легко определяется (рассчитывается
по составным частям), а накладных расходов очень мало. В результате создание нового экземпляра
предпочтительнее повторного использования ссылок, даже если Объект-Значения использоуется для
предоставления одного и того же значения. Равенство проверяется на основе сопоставимости
всех полей экземпляров.

## Определение
Уорд Каннингем (Ward Cunningham) дает следующее [определение](http://c2.com/cgi/wiki?ValueObject) Объекту Значения:
>Это мера или описание чего-либо. Примерами Объектов Значения являются такие вещи, как числа, даты, денежные суммы и строки.
>Обычно это не большие Объекты, которые используются довольно широко.
>Их идентичность основана на их состояни, а не на идентификаторе Объекта. 
>Таким образом, вы можете иметь несколько копий одного концептуального Объекта Значения.
>Каждая банкнота достоинством 5 долларов имеет свою собственную идентификацию (благодаря
>своему серийному номеру), но экономия денежных средств зависит от того, что
>каждая банкнота достоинством в 5 долларов имеет ту же стоимость, что и любая другая банкнота в 5 долларов.

Мартин Фаулер дает следующее [определение](http://martinfowler.com/bliki/ValueObject.html) Объекту Значения:
>Это маленький Объект, такой как деньги или диапозон дат. Их ключевое свойство
>заключается в том, что они следуют семантике значений, а не ссылочной семантике.
>Мы можем так утверждать, потому что их понятие равенства не основано на идентификаторе,
>вместо этого два Объекта Значения равны, если все их поля равны. 
>Хотя все поля равны, вам не нужно сравнивать все поля, если подмножество уникально - 
>например, кодов валюты для объектов валюты достаточно чтобы проверить равенство.
>Общая эвристика заключается в том, что Объекты Значения должны быть полностью неизменными.
>Если вы хотите изменить объект значения, вы должны заменить объект новым и не иметь
>возможности обновлять значения самого Объекта Значения. Обновляемые Объекты Значения приводят
>к проблемам с наложением имен.

Примерами Объектов Значения являются числа, текстовые строки, даты, время, полное имя человека
>***Упражнение***
>Попробуйте найти дополнительные Объекты Значения в вашем текущем Домене.

## Объекты значения vs Сущности

Рассмотрим следующие примеры из [Википедии](http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD), чтобы лучше понять разница между
Объектами Значениями и Сущностями:
- Объект Значения. Когда люди обменивают долларовые банкноты, они обычно не 
различают каждый уникальную купюру; они обеспокоены только номинальной стоимостью
долларовой банкноты. В этом контексте далларовые банкноты ялвяются Объектами Значения.
Тем не менее, Федеральный Резерв может быть обеспокоен каждым уникальным счетом; в этом контексте
каждый счет был бы сущностью.
- Сущность. Большинство авиакомпаний различают каждое место уникально на каждом рейсе.
Каждое место в данном контексте является сущностью. Однако Southwest Airlines, EasyJet и
Ryanair не различают каждое место; все места одинаковые. В этом контексте место на самом деле является
Объектом Значения.

>***Упражнение***
>Подумайте о понятии адреса (индекс, улица, номер дома и т.д.). Каков возможный
>контекст, в котором адрес может быть смоделирован как сущность, а не как объект значения? 
>Обсудите ваши выводы с коллегами.

## Пример "Валюта" и "Стоимость"

Объекты Значения "Валюта" и "Денежная Стоимость", вероятно, являются наиболее
часто используемыми примерами для объяснения Объектов Значения, благодаря 
[патерну "Деньги" (Money)](http://martinfowler.com/eaaCatalog/money.html).
Этот шаблон проектирования предоставляет решение для моделирования задачи, которая позволяет
избежать проблемы округления с плавающей запятой, что, в свою очередь, позволяет выполнять
детерминированные вычисления.

В реальном мире валюта описывает денежные единицы так же, как метры и ярды описывают единицы расстояния.
Каждая валюта представлена трехбуквенным ISO кодом в верхнем регистре:
```php
class Currency
{
    private $isoCode;
    public function __construct($anIsoCode)
    {
        $this->setIsoCode($anIsoCode);
    }

    private function setIsoCode($anIsoCode)
    {
        if (!preg_match('/^[A-Z]{3}$/', $anIsoCode)) {
            throw new InvalidArgumentException();
        }
        $this->isoCode = $anIsoCode;
    }

    public function isoCode()
    {
        return $this->isoCode;
    }
}
```
Одна из основных целей Объектов Значения так же являются святым Граалем ООП: инкапсуляция.
Следуя этому шаблону, вы получите выделенное место для размещения всей проверки,
логики сравнения и поведения для данной концепции.

>***Дополнительные Проверки Валюты***
>В предыдущем примере кода мы можем построить валюту с кодом ISO равным ААА.
>Это не валидно, валюты с такой кодировкой не существует. Напишите более конкретное правило,
>которое проверит, действителен ли код ISO. Полный список действительный валютных кодов ISO 
>можно найти 
>[здесь](https://www.xe.com/iso4217.php). Если вам нужна помощь, взгляните на библиотеку 
>[Money Packagist](https://github.com/moneyphp/money)

Деньги используются для измерения определенной суммы валюты. Они моделируются с 
помощью суммы и валюты. Сумма, в случае паттерна Money, реализуется с использованием
целочисленного представления наименее значимой доли валюты - например, в центах долларов США или 
копеек в рублях России.

В качестве бонуса вы также можете заметить, что мы используем самоинкапсуляцию
для установки кода ISO, которая центарлизует изменения в самом Объекте Значения:
```php
class Money
{
    private $amount; 
    private $currency;

    public function __construct($anAmount, Currency $aCurrency)
    {
        $this->setAmount($anAmount);
        $this->setCurrency($aCurrency);
    }

    private function setAmount($anAmount)
    {
        $this->amount = (int) $anAmount;
    }

    private function setCurrency(Currency $aCurrency)
    {
        $this->currency = $aCurrency;
    }

    public function amount()
    {
        return $this->amount;
    }

    public function currency()
    {
        return $this->currency;
    }
}
```
Теперь, когда вы знаете формальное определение Объектов Значений, давайте
углубимся в тот мощной функционал который они предоставляют.

## Характеристики

При моделированние концепции Единого Языка вашего Домена, вы всегда должны отдавать
предпочтение Объектам Значения, а не Сущностям. Объекты Значения проще создавать, тестировать, 
использовать и поддерживать.

Исходя из этого, вы можете определить, может ли рассматриваемая концепция моделироваться как 
Объект Значения, если:

- Он измеряет, оценивает или описывает объект предметной области.
- Он может быть имутабельным (неизменяемым).
- Он моделирует концептуальное целое, объединяя связанные атрибуты в единое целое.
- Он может быть сравнен с другим таким же объектом через равенство всех его аттрибутов.
- Он полностью заменяется при изменении способа измерения или описания.
- Он предоставляет связанным с ним объектам функцию без побочных эффектов.

### Измерение, Оценивание, или Описание
Как говорилось выше, Объект Значения не должен рассматриваться как вещь в вашем Домене.
В качестве значения Объект Значения измеряет, оценивает или описывает концепцию в Домене.

В нашем примере объект `Currency` описывает тип объекта `Money`. Объект `Money` измеряет
или количественно оценивает единицы данной валюты.

### Имутабельность
Это один из важнейших аспектов для усвоения. Объекты Значения не могут быть измнены в 
течении всего периода их использования. Благодаря этой имутабельности Объект Значения
легко создавать и тестировать, они не содержат нежелательных/неожиданных побочных эффектов.
Таким образом, Объекты Значения должны создаваться через их конструкторы. 
Чтобы создать его, вы обычно передаете необходимые типы притивов или другие Объект Значения
через конструктор.

Объекты Знечения всегда находятся в валидном состоянии; Вот почему мы создаем их за один
шаг. Пустые конструкторы с несколькими сеттерами или геттерами переносят 
ответственность за создание на клиента что приводит к Анемичность Доменой Модели, что считается антипатерном.

Также важно отметить, что не рекомендуется хранить ссылки на Сущности внутри ваших Объектов Значения.
Сущности являются изменяемыми, и хранение ссылок на них может привести к 
нежелательным побочным эффектам в Объекте Значения.

В языках с `перегрузкой методов` таких как Java, вы можете создавать несколько
конструкторов с одинаковыми именами. Каждому из этих конструкторов предоставляются
различные входные параметры для создания одного и того же типа результирующего объекта.
В PHP мы можем реализовать аналогичную возможность с помощью фабричных методов.
Эти специфичные фабричные методы также известны как семантические конструкторы.
Основная цель `fromMoney` метода предоставить больше контекстуального значения, чем 
простой конструктор. Более радикальные подходы предлагают сделать метод
`__construct` приватным и для создания объекта используют семантический конструктор.

В нашем объекте `Money` мы могли бы реализовать несколько полезных 
фабричных методово, какие как:
 ```php
class Money
{
    // ...
    public static function fromMoney(Money $aMoney)
    {
        return new self(
            $aMoney->amount(),
            $aMoney->currency()
        );
    }
    public static function ofCurrency(Currency $aCurrency)
    {
        return new self(0, $aCurrency);
    }
}
```
Использую ключевое слово `self`, мы не связываем код с именем класса. 
Таким образом, изменение имени класса или пространства имен не повлияет на работоспособность
фабричных методов. Эта маленькая деталь реализации поможет нам при рефакторинге на более
познем этапе.

>***`static` или `self`***
>Использование `static` вместо `self` может привести к нежелательным проблемам, когда Объект Значения
>наследуется от другого Объекта Значения.

Учитывая имутабельность, нам нужно понять как обрабатывать действия изменения объекта, которые
обычно встречаются в контексте состояния. Если нам требуется измненеия состояния, мы должны вернуть
новой экземпляр Объекта Значения в котором учтено это измненение. Например если мы хотим увеличить
сумму Объекта Значения `Money`, мы вместо того чтобы этому объекту присвоить новое значени должны создать и вернуть новый объект.

К счастью, следовать этому правилу достаточно просто:
```php
class Money
{
    // ...
    public function increaseAmountBy($anAmount)
    {
        return new self(
            $this->amount() + $anAmount,
            $this->currency()
        );
    }
}
```
Объект `Money` возращаемый функцией `increaseAmountBy`, отличается от объекта `Money` в которым был 
иницирован вызов функции. Это можно наблюдать в приведенных ниж примерах проверов соппоставимости:
```php
<?php
$aMoney = new Money(100, new Currency('USD')); 
$otherMoney = $aMoney->increaseAmountBy(100);

var_dump($aMoney === $otherMoney); // bool(false)

$aMoney = $aMoney->increaseAmountBy(100);
var_dump($aMoney === $otherMoney); // bool(false)
```
### Концептуальное Целое
Может возникнуть вопрос: "Почему бы просто не реализовать что-то похожее как на примере ниже, полностью
избегая необходимости в Объекте Значения?":
```php
class Product
{
    private id; 
    private name;
    /**
    * @var int
    */
    private $amount;
    /**
    * @var string
    */
    private $currency;
    // ...
}
```
У этого подхода есть некоторые значительные недостатки, например, если вы хотите проверить ISO. 
В действительности нет необходимости в том чтобы `Product` отвечал за валидацию ISO валюты `Currency`
(это нарушает первое правило SOLID, Единство Ответственности). Это еще более заметно, если вы
хотите повторно использовать сопутствующую логику в других частях вашего Домена (придерживаясь принципа DRY).

Учитивая эти факторы, описанный пример является идеальным каждидатом для абстрагирования в Объект Значения.
Использование этой бастракции не только дает вам возможность группировать связанные свойства,
но также позволяет создавать концепции более высокого порядка и более конкретный Единый Язык.

>***Упражениние***
> Обсудите с коллегами, может ли email считаться Объектом Значения. Имеет ли значение контект в котором
>используется объект?
### Равенство (эквиваленство) Значения

Как обсуждалось ранее, два Объекта-Значения равны, если содержимое, которое
они измеряют, оценивают, или описывают, одинаково.

Например представьте два объекта `Money` наминалом 1 USD. Можем мы их счетать равными?
В реальном мире две купюры в 1 USD оцениваются одинаково? Скорее всего да.
Возращаясь к коду, расматриваемые два Объекта-Значения являются двумя разными
экземплярами объекта, однако они представляют одниковое значение что делает их подобными.

Касаемо PHP, обычно сравнивают два Объекта-Значения оператором `==`. Если мы изучим
документацию PHP касаемо оператора то увидем интересное поведение:
>При использовании оператора сравнения `==` переменные объекта сравниваются простым способом
>а именно: два экземпляра объекта равно, если они имеют одинаковые атрибуты
>и значения, и являются экземплярами одного и того же класса.
 Данное поведение соответствует нашему формальному описанию Объекта-Значения. 
>Однако, поскольку присутствует предикат точного совпадения имени класса, вам следует 
>быть осторожными при проверке подтипов Объектов-Значения.

К сожалению, даже более строгий оператор `===` нам не поможет:
>При использовании оператора сравнения `===` переменные объекта равны только тогда, когда они
>ссылаются на один и тот же экземпляр одного и того же класса.

Следующий пример должен помочь понять эти тонкие различия:
```php
<?php
    $a = new Currency('USD'); 
    $b = new Currency('USD');
    var_dump($a == $b); // bool(true)
    var_dump($a === $b); // bool(false)
    $c = new Currency('EUR');
    var_dump($a == $c); // bool(false)
    var_dump($a === $c); // bool(false)
```
Решение состоит в том чтобы реализовать метод сравнения в каждом классе
Объектов Значения.
Этот метод выполняет проверку типа и равенства его составных атрибутов.
Сравнение абстрактных типов данных легко реализовать с помощью
 встроенной подсказки типов в PHP. 
 Вы также можете использовать функцию `get_class()` 
 для помощи в проверке сопоставимости при необходимости.